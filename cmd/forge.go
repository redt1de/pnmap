/*
Copyright Â© 2023 NAME HERE <EMAIL ADDRESS>
*/
package cmd

import (
	"encoding/csv"
	"encoding/xml"
	"fmt"
	"log"
	"os"
	"strconv"
	"strings"
	"time"

	nmap2 "github.com/Ullaakut/nmap/v3"
	// "github.com/redt1de/pnmap/nmap"
	"github.com/spf13/cobra"
)

const fileHeader = `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE nmaprun>
<?xml-stylesheet href="file:///usr/bin/../share/nmap/nmap.xsl" type="text/xsl"?>
<!-- Generated by Pnmap (github.com/redt1de/pnmap) -->

`

// forgeCmd represents the forge command
var forgeCmd = &cobra.Command{
	Use:   "forge",
	Short: "generate an Nmap XML file from a CSV",
	Long: `
Example CSV file:
ip,hostnames,tcp_ports,udp_ports
127.0.0.1,"localhost,home.local","80,443,22",
	
	`,
	Run: func(cmd *cobra.Command, args []string) {

		var prtTrack, hostTrack []string
		outpath, _ := cmd.Flags().GetString("out")
		fpath, _ := cmd.Flags().GetString("in")
		if fpath == "" {
			log.Fatal("Please provide a file path")
		}

		csvFile, err := os.Open(fpath)
		if err != nil {
			log.Fatal("failed to open the CSV:", err)
		}

		defer csvFile.Close()

		csvLines, err := csv.NewReader(csvFile).ReadAll()
		if err != nil {
			fmt.Println(err)
		}
		// out := nmap.NmapRun{}
		out := &nmap2.Run{
			XMLName:          xml.Name{Space: "nmaprun", Local: "nmaprun"},
			Scanner:          "pnmap forge",
			Args:             strings.Join(os.Args, " "),
			Verbose:          nmap2.Verbose{Level: 0},
			Version:          "7.91",
			Start:            nmap2.Timestamp{},
			StartStr:         time.Now().Format("Mon Jan 2 15:04:05 2006"),
			XMLOutputVersion: "1.06",
			ScanInfo:         nmap2.ScanInfo{Type: "connect", Protocol: "tcp", NumServices: 0, Services: "-"},
			Debugging:        nmap2.Debugging{Level: 0},
			Stats:            nmap2.Stats{Finished: nmap2.Finished{Time: nmap2.Timestamp{}, Elapsed: 1.0, TimeStr: time.Now().Format("Mon Jan 2 15:04:05 2006")}, Hosts: nmap2.HostStats{Up: 1, Down: 0, Total: 1}},
			Targets:          []nmap2.Target{{Specification: ""}},
			TaskBegin:        []nmap2.Task{{Time: nmap2.Timestamp{}, ExtraInfo: ""}},
			TaskEnd:          []nmap2.Task{{Time: nmap2.Timestamp{}, ExtraInfo: ""}},
			TaskProgress:     []nmap2.TaskProgress{{Time: nmap2.Timestamp{}, Percent: 0, Remaining: 0}},
		}
		for _, line := range csvLines {
			if line[0] == "ip" {
				continue
			}
			var hostnames []nmap2.Hostname
			ip := line[0]
			hostnamestmp := strings.Split(line[1], ",")
			for _, h := range hostnamestmp {
				hostnames = append(hostnames, nmap2.Hostname{Name: h, Type: "PTR"})
			}
			portsT := strings.Split(line[2], ",")

			var portlistT []nmap2.Port
			for _, p := range portsT {
				if p == "" {
					continue
				}
				prtTrack = append(prtTrack, p)
				prtnum, _ := strconv.Atoi(p)
				if prtnum == 0 {
					continue
				}
				portlistT = append(portlistT, nmap2.Port{ID: uint16(prtnum), Protocol: "tcp", State: nmap2.State{State: "open", Reason: "syn-ack"}, Service: nmap2.Service{Name: getService(p + "/tcp")}})
			}

			portsU := strings.Split(line[3], ",")
			var portlistU []nmap2.Port
			for _, p := range portsU {
				if p == "" {
					continue
				}
				prtTrack = append(prtTrack, "U:"+p)
				prtnum, _ := strconv.Atoi(p)
				if prtnum == 0 {
					continue
				}
				portlistU = append(portlistU, nmap2.Port{ID: uint16(prtnum), Protocol: "udp", State: nmap2.State{State: "open"}, Service: nmap2.Service{Name: getService(p + "/udp")}})
			}

			addrType := "ipv4"
			if !IsIPv4(ip) && IsIPv6(ip) {
				addrType = "ipv6"
			}
			addr := nmap2.Address{Addr: ip, AddrType: addrType}

			host := nmap2.Host{
				Status:    nmap2.Status{State: "up", Reason: "user-set", ReasonTTL: 0},
				Addresses: []nmap2.Address{addr},
				Hostnames: hostnames,
				Ports:     append(portlistT, portlistU...),
				StartTime: nmap2.Timestamp{},
				EndTime:   nmap2.Timestamp{},
			}
			out.Hosts = append(out.Hosts, host)
			hostTrack = append(hostTrack, ip)

		}
		uhosts := unique(hostTrack)
		uprts := unique(prtTrack)
		out.ScanInfo.Services = strings.Join(uprts, ",")
		out.ScanInfo.NumServices = len(uprts)
		out.Stats.Hosts.Up = len(uhosts)
		out.Stats.Hosts.Total = len(uhosts)

		WriteXML(out, outpath)

	},
}

func init() {
	rootCmd.AddCommand(forgeCmd)
	forgeCmd.Flags().StringP("in", "i", "", "csv file to be processed")
	forgeCmd.Flags().StringP("out", "o", "./pnamp-forged.xml", "output file")
}

// takes 80/tcp, 443/tcp, 5000/udp
func getService(prt string) string {
	servDb, err := ReadLines("/usr/share/nmap/nmap-services")
	if err != nil {
		log.Println("failed to read /usr/share/nmap/nmap-services")
	}
	for _, line := range servDb {
		if strings.HasPrefix(line, "#") {
			continue
		}
		if strings.Contains(line, fmt.Sprintf("\t%s", prt)) {
			return strings.Split(line, "\t")[0]
		}
	}

	return "tcpwrapped"
}

func WriteXML(n *nmap2.Run, fpath string) error {

	x, err := xml.MarshalIndent(n, "", "  ")
	if err != nil {
		return err
	}

	out := append([]byte(fileHeader), x...)
	os.WriteFile(fpath, out, 0644)
	return nil
}
